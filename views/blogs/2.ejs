<!DOCTYPE html>
<html>

<head>
  <% include ../partials/header.ejs%>
  <link href = "/css/common.css" rel = "stylesheet" />
  <link href = "/css/landing.css" rel ='stylesheet' />
  <link href = "/css/start.css" rel="stylesheet" />
  <link href = "/css/icons.css" rel="stylesheet" />
  <link href = "/css/blog/specific.css" rel = "stylesheet" />
  <link href="https://unpkg.com/aos@2.3.1/dist/aos.css" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://unpkg.com/aos@2.3.1/dist/aos.js"></script>
</head>

<body>

  <div id = "navbar">
    <a href = "/">Home</a>
    <a href = "/blog">Blog</a>
    <a href = "/projects">Projects</a>
    <a href = "/media">Media</a>
  </div>

  <h1>Simple Node.JS Server</h1>
  <h4>July 27, 2019</h4>

  <center><img src = "/images/blog2.jpg" /></center>

  <div class = "text">
    <p>
      So you know enough Javascript to create a dynamic front-end, but now you want to try your hand at creating a backend for your website?
      <br/><br/>
      You’ve come to the right place.
      <br/><br/>
      In this post, I’m going to walk you through how to create a basic Node.JS server utilizing Express.
      <br/><br/>
      This tutorial will assume that you’ve already installed <a href = "https://nodejs.org/en/download/">Node.JS</a> onto your development machine as well as the <a href = "https://www.npmjs.com/package/express.">Express node package</a>.
      <br/><br/>
      I’m going to go line by line letting you know what’s happening, scroll to the bottom for the entire index.js file.</p>
      <br/><br/>
  </div>
  <script src="https://gist.github.com/matthewjgunton/00329105a64051e5d2ca4cbc746ff721.js"></script>

  <div class = "text">
    <p>We start the file by reading in our express node package & then essentially creating an instance of that object in the variable “app”. The final variable is to help us in the next stage.</p>
  </div>
  <script src="https://gist.github.com/matthewjgunton/cb5d3b8bcf25f94e3cdb185ba11120cb.js"></script>

  <div class = "text">
    <p>
      The code above creates the routes for our web app. Going from the top to the bottom, the first line lets express know what type of HTTP Requests will be handled by this function. For instance, .get will only be activated when a get request is made to the route, and the same goes for .post with post requests. When trouble shooting, this distinction is important to remember. You’ll save yourself a lot of time by testing the routes with the right HTTP request.
  Next, the callback function we pass has 2 parameters, req & res, short for request & response. The request variable carries with it all the variables from the client. When using a post request, this is the object all the data will be in. Response is what gets sent back to the user.
  <br/><br/>
  The second line is what actually sends back an HTML file to the client. Beginning with the status function, we’ll break down the line. In HTTP requests, there are a myriad of different responses. 200s in general mean a successful request has been made, while 300s indicate a redirect, and 400 and 500 suggest some type of error, with the specific kind of error being made clear by the number sent back. By adding the 200 status to the response object, we’re letting our client’s browser know their request was successful. Next, the sendFile function is sending back a file from our server to the client. The parameter we pass into that function is the path to the file. If you put the absolute file path in here, then you’ll have to adjust the file path every time you change computers. While this may not seem like a big deal, remember that if your server is running on any machine other than the one you’re developing one, this means you’ll have to change it each time you switch. This can be a hassle not worth going through, so we make us our path node package to help us create a dynamic path to the file. the ‘__dirname’ variable simply tells the server to look into the directory the index.js file is in. From there you can use typical dynamic file finding to reach the file. In our case, the index.html file is in the same file directory as index.js, so we simply put the file name after.
  </p>
  </div>
  <script src="https://gist.github.com/matthewjgunton/f899d01a5949b408b46f44e9688d2884.js"></script>
  <div class = "text">
    <p>
These two functions are quite simple. The first one catches any calls to the server that are not defined by our .get & .post routes. If caught, it sends a 404 error and gives the user the text ‘error’. The listen functions lets the server know which port to communicate off of. If you’re interested about why we need to specify which port the internet traffic is sent through, you should look more into computer networking and ports.
<br/><br/>
Go into your terminal, open the directory with index.js inside of it and run ‘node index’.
<br/><br/>
And after that, your server is all set!
</p>
  </div>
  <center><p>Full file is availabe <a href = "https://gist.github.com/matthewjgunton/7c56b0e430b9937a08f26549963bc77c">Here</a></p></center>

  <% include ../partials/footer.ejs%>

</body>

</html>
